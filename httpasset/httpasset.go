// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a Modified
// BSD License that can be found in the LICENSE file.

// Package httpasset provides a http.Handler that will
// serve files using the methods generated by go-bindata.
package httpasset

import (
	"bytes"
	"net/http"
	"os"
	"path"
	"strings"
	"unicode"

	"github.com/tmthrgd/go-hex"
)

const maxETagLen = 2 * 64

// AssetAndInfo represents the generated AssetAndInfo method.
type AssetAndInfo func(name string) (data []byte, info os.FileInfo, err error)

type fileInfo interface {
	os.FileInfo

	OriginalName() string
	FileHash() []byte
}

type fileHandler struct {
	asset      AssetAndInfo
	compressed AssetAndInfo
	etagLen    int
}

// New returns a new asset filesystem.
func New(asset AssetAndInfo) http.Handler {
	return &fileHandler{asset: asset}
}

// NewWithETag returns a new asset filesystem that will
// include an ETag derived from the assets FileHash() if
// implemented.
func NewWithETag(asset AssetAndInfo, etagLen int) http.Handler {
	return NewCompressedWithETag(asset, nil, etagLen)
}

// NewCompressed returns a new asset filesystem that will
// optionally serve precompressed .gz and .br resources from
// compressed.
func NewCompressed(asset, compressed AssetAndInfo) http.Handler {
	return &fileHandler{asset: asset, compressed: compressed}
}

// NewCompressedWithETag returns a new asset filesystem that
// will optionally serve precompressed .gz and .br resources
// from compressed. It will include an ETag derived from the
// assets FileHash() if implemented.
func NewCompressedWithETag(asset, compressed AssetAndInfo, etagLen int) http.Handler {
	if etagLen <= 0 {
		etagLen = 0
	} else if etagLen > maxETagLen {
		etagLen = maxETagLen
	}

	return &fileHandler{asset, compressed, etagLen}
}

func (fh *fileHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	name := strings.TrimPrefix(path.Clean(r.URL.Path), "/")

	data, info, err := fh.asset(name)
	if err != nil {
		code := toHTTPError(err)
		http.Error(w, http.StatusText(code), code)
		return
	}

	fi, ok := info.(fileInfo)
	if ok && fh.etagLen != 0 {
		hash := fi.FileHash()

		l := fh.etagLen
		if l > 2*len(hash) {
			l = 2 * len(hash)
		}

		var etag [2 + maxETagLen]byte
		etag[0] = '"'
		hex.Encode(etag[1:], hash[:((l+1)&^1)/2])
		etag[1+l] = '"'

		w.Header().Set("Etag", string(etag[:2+l]))
	}

	if fh.compressed != nil {
		if ok {
			name = fi.OriginalName()
		}

		brotli, gzip := parseAcceptEncoding(r.Header.Get("Accept-Encoding"))
		if (brotli && fh.serveCompressed(w, r, info, name+".br", "br", len(data))) ||
			(gzip && fh.serveCompressed(w, r, info, name+".gz", "gzip", len(data))) {
			return
		}
	}

	http.ServeContent(w, r, info.Name(), info.ModTime(), bytes.NewReader(data))
}

func (fh *fileHandler) serveCompressed(w http.ResponseWriter, r *http.Request, info os.FileInfo, name, enc string, size int) bool {
	data, _, err := fh.compressed(name)
	if err != nil {
		if os.IsNotExist(err) {
			return false
		}

		code := toHTTPError(err)
		http.Error(w, http.StatusText(code), code)
		return true
	} else if len(data) >= size {
		return false
	}

	w.Header().Set("Content-Encoding", enc)
	http.ServeContent(w, r, info.Name(), info.ModTime(), bytes.NewReader(data))
	return true
}

func isFieldSeparator(r rune) bool {
	return r == ';' || unicode.IsSpace(r)
}

func parseAcceptEncoding(header string) (brotli, gzip bool) {
outer:
	for _, value := range strings.Split(header, ",") {
		fields := strings.FieldsFunc(value, isFieldSeparator)
		if len(fields) == 0 {
			continue
		}

		for _, field := range fields[1:] {
			switch field {
			case "q=0", "q=0.0", "q=0.00", "q=0.000",
				"Q=0", "Q=0.0", "Q=0.00", "Q=0.000":
				continue outer
			}
		}

		switch strings.ToLower(fields[0]) {
		case "br":
			brotli = true
		case "gzip":
			gzip = true
		}
	}

	return
}

// toHTTPError returns a non-specific HTTP error message and status code
// for a given non-nil error value. It's important that toHTTPError does not
// actually return err.Error(), since msg and httpStatus are returned to users,
// and historically Go's ServeContent always returned just "404 Not Found" for
// all errors. We don't want to start leaking information in error messages.
func toHTTPError(err error) (code int) {
	switch {
	case os.IsNotExist(err):
		return http.StatusNotFound
	case os.IsPermission(err):
		return http.StatusForbidden
	default:
		return http.StatusInternalServerError
	}
}
