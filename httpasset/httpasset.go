// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a Modified
// BSD License that can be found in the LICENSE file.

// Package httpasset provides a http.Handler that will
// serve files using the methods generated by go-bindata.
package httpasset

import (
	"bytes"
	"net/http"
	"os"
	"path"
	"strings"

	"github.com/golang/gddo/httputil/header"
	"github.com/tmthrgd/go-hex"
)

const maxETagLen = 2 * 64

// AssetAndInfo represents the generated AssetAndInfo method.
type AssetAndInfo func(name string) (data []byte, info os.FileInfo, err error)

type fileInfo interface {
	os.FileInfo

	OriginalName() string
	FileHash() []byte
}

// FileServer is a http.Handler that serves files
// from the provided AssetAndInfo methods.
//
// It will serve files from Asset by default but
// will try to serve files from Brotli if the
// client supports brotli compression, or from Gzip
// if client only supports Gzip.
//
// EtagLen optionally specifies the length of Etags
// to generate, if the os.FileInfo returned by Asset
// implements the FileHash() method. The Etag will be
// a hexadecimal encoded string truncated to EtagLen.
type FileServer struct {
	Asset  AssetAndInfo
	Brotli AssetAndInfo
	Gzip   AssetAndInfo

	EtagLen int
}

// New returns a new asset filesystem.
func New(asset AssetAndInfo) http.Handler {
	return &FileServer{Asset: asset}
}

// NewWithETag returns a new asset filesystem that will
// include an ETag derived from the assets FileHash() if
// implemented.
func NewWithETag(asset AssetAndInfo, etagLen int) http.Handler {
	return &FileServer{Asset: asset, EtagLen: etagLen}
}

// NewCompressed returns a new asset filesystem that will
// optionally serve precompressed .gz and .br resources from
// compressed.
func NewCompressed(asset, compressed AssetAndInfo) http.Handler {
	return NewCompressedWithETag(asset, compressed, 0)
}

// NewCompressedWithETag returns a new asset filesystem that
// will optionally serve precompressed .gz and .br resources
// from compressed. It will include an ETag derived from the
// assets FileHash() if implemented.
func NewCompressedWithETag(asset, compressed AssetAndInfo, etagLen int) http.Handler {
	if etagLen <= 0 {
		etagLen = 0
	} else if etagLen > maxETagLen {
		etagLen = maxETagLen
	}

	return &FileServer{
		Asset: asset,
		Brotli: func(name string) (data []byte, info os.FileInfo, err error) {
			return compressed(name + ".br")
		},
		Gzip: func(name string) (data []byte, info os.FileInfo, err error) {
			return compressed(name + ".gz")
		},

		EtagLen: etagLen,
	}
}

func (fs *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	name := strings.TrimPrefix(path.Clean(r.URL.Path), "/")

	data, info, err := fs.Asset(name)
	if err != nil {
		code := toHTTPError(err)
		http.Error(w, http.StatusText(code), code)
		return
	}

	fi, ok := info.(fileInfo)
	if ok && fs.EtagLen != 0 {
		hash := fi.FileHash()

		l := fs.EtagLen
		if l > 2*len(hash) {
			l = 2 * len(hash)
		}

		var etag [2 + maxETagLen]byte
		etag[0] = '"'
		hex.Encode(etag[1:], hash[:((l+1)&^1)/2])
		etag[1+l] = '"'

		w.Header().Set("Etag", string(etag[:2+l]))
	}

	if fs.Brotli != nil || fs.Gzip != nil {
		if ok {
			name = fi.OriginalName()
		}

		var brotli, gzip bool

		for _, spec := range header.ParseAccept(r.Header, "Accept-Encoding") {
			switch spec.Value {
			case "br":
				brotli = spec.Q > 0
			case "gzip":
				gzip = spec.Q > 0
			}

			if brotli && gzip {
				break
			}
		}

		if (brotli && fs.Brotli != nil && serveCompressed(w, r, info, fs.Brotli, name, "br", len(data))) ||
			(gzip && fs.Gzip != nil && serveCompressed(w, r, info, fs.Gzip, name, "gzip", len(data))) {
			return
		}
	}

	http.ServeContent(w, r, info.Name(), info.ModTime(), bytes.NewReader(data))
}

func serveCompressed(w http.ResponseWriter, r *http.Request, info os.FileInfo, assetAndInfo AssetAndInfo, name, enc string, size int) bool {
	data, _, err := assetAndInfo(name)
	if err != nil {
		if os.IsNotExist(err) {
			return false
		}

		code := toHTTPError(err)
		http.Error(w, http.StatusText(code), code)
		return true
	} else if len(data) >= size {
		return false
	}

	w.Header().Set("Content-Encoding", enc)
	http.ServeContent(w, r, info.Name(), info.ModTime(), bytes.NewReader(data))
	return true
}

// toHTTPError returns a non-specific HTTP error message and status code
// for a given non-nil error value. It's important that toHTTPError does not
// actually return err.Error(), since msg and httpStatus are returned to users,
// and historically Go's ServeContent always returned just "404 Not Found" for
// all errors. We don't want to start leaking information in error messages.
func toHTTPError(err error) (code int) {
	switch {
	case os.IsNotExist(err):
		return http.StatusNotFound
	case os.IsPermission(err):
		return http.StatusForbidden
	default:
		return http.StatusInternalServerError
	}
}
