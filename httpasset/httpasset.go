// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a Modified
// BSD License that can be found in the LICENSE file.

// Package httpasset provides a http.Handler that will
// serve files using the methods generated by go-bindata.
package httpasset

import (
	"bytes"
	"net/http"
	"os"
	"path"
	"strings"
	"unicode"

	"github.com/tmthrgd/go-hex"
)

const maxETagLen = 2 * 64

// AssetAndInfo represents the generated AssetAndInfo method.
type AssetAndInfo func(name string) (data []byte, info os.FileInfo, err error)

type fileInfo interface {
	os.FileInfo

	OriginalName() string
	FileHash() []byte
}

type fileHandler struct {
	asset      AssetAndInfo
	compressed AssetAndInfo
	etagLen    int
}

// New returns a new asset filesystem.
func New(asset AssetAndInfo) http.Handler {
	return &fileHandler{asset: asset}
}

// NewWithETag returns a new asset filesystem that will
// include an ETag derived from the assets FileHash() if
// implemented.
func NewWithETag(asset AssetAndInfo, etagLen int) http.Handler {
	return NewCompressedWithETag(asset, nil, etagLen)
}

// NewCompressed returns a new asset filesystem that will
// optionally serve precompressed .gz and .br resources from
// compressed.
func NewCompressed(asset, compressed AssetAndInfo) http.Handler {
	return &fileHandler{asset: asset, compressed: compressed}
}

// NewCompressedWithETag returns a new asset filesystem that
// will optionally serve precompressed .gz and .br resources
// from compressed. It will include an ETag derived from the
// assets FileHash() if implemented.
func NewCompressedWithETag(asset, compressed AssetAndInfo, etagLen int) http.Handler {
	if etagLen <= 0 {
		etagLen = 0
	} else if etagLen > maxETagLen {
		etagLen = maxETagLen
	}

	return &fileHandler{asset, compressed, etagLen}
}

func (fh *fileHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	name := strings.TrimPrefix(path.Clean(r.URL.Path), "/")

	data, info, err := fh.asset(name)
	if err != nil {
		code := http.StatusInternalServerError
		if os.IsNotExist(err) {
			code = http.StatusNotFound
		} else if os.IsPermission(err) {
			code = http.StatusForbidden
		}

		http.Error(w, http.StatusText(code), code)
		return
	}

	fi, ok := info.(fileInfo)
	if ok && fh.etagLen != 0 {
		hash := fi.FileHash()

		l := fh.etagLen
		if l > 2*len(hash) {
			l = 2 * len(hash)
		}

		var etag [2 + maxETagLen]byte
		etag[0] = '"'
		hex.Encode(etag[1:], hash[:((l+1)&^1)/2])
		etag[1+l] = '"'

		w.Header().Set("Etag", string(etag[:2+l]))
	}

	if fh.compressed == nil {
		http.ServeContent(w, r, info.Name(), info.ModTime(), bytes.NewReader(data))
		return
	}

	accept := parseAcceptEncoding(r.Header.Get("Accept-Encoding"))

	if ok {
		name = fi.OriginalName()
	}

	for _, enc := range [...]struct{ name, ext string }{
		{"br", ".br"},
		{"gzip", ".gz"},
	} {
		if _, has := accept[enc.name]; !has {
			continue
		}

		if compressed, _, err := fh.compressed(name + enc.ext); err != nil {
			if os.IsNotExist(err) {
				continue
			} else if os.IsPermission(err) {
				http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
				return
			}

			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			return
		} else if len(compressed) < len(data) {
			w.Header().Set("Content-Encoding", enc.name)

			data = compressed
			break
		}
	}

	http.ServeContent(w, r, info.Name(), info.ModTime(), bytes.NewReader(data))
}

func isFieldSeparator(r rune) bool {
	return r == ';' || unicode.IsSpace(r)
}

func parseAcceptEncoding(header string) (c map[string]struct{}) {
	c = make(map[string]struct{})

outer:
	for _, value := range strings.Split(header, ",") {
		fields := strings.FieldsFunc(value, isFieldSeparator)
		if len(fields) == 0 {
			continue
		}

		for _, field := range fields[1:] {
			switch field {
			case "q=0", "q=0.0", "q=0.00", "q=0.000",
				"Q=0", "Q=0.0", "Q=0.00", "Q=0.000":
				continue outer
			}
		}

		c[strings.ToLower(fields[0])] = struct{}{}
	}

	return
}
